package com.makebono.javaplayland.concurrency.basicmultithread.locks;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/** 
 * @ClassName: LocksExample 
 * @Description: Example for different way to provide locks.
 * @author makebono
 * @date 2018年1月8日 下午3:59:25 
 *  
 */
public class LocksExample {
    // Will be on inifinite loop since every int generated by the EvenGenerator.next() is even.
    public static void demoSync() {
        EvenCheck.test(new EvenGenerator(), true);
    }

    // Will eventually trigger termination since there will be conflict when calling EvenGenerator.nextAsync(). Which
    // means, odd number will be pass into testing method.
    public static void demoAsync() {
        EvenCheck.test(new EvenGenerator(), false);
    }

    public static void demoLock() {
        EvenCheckWithLock.test(new EvenGenerator());
    }
}

class EvenGenerator {
    final Lock lock = new ReentrantLock();
    private int initial = 0;
    private volatile boolean isCanceled = false;

    // Protected by synchronized modifier. Would be safe.
    public synchronized int next() {
        this.initial++;
        this.initial++;
        return this.initial;
    }

    public int nextAsync() {
        this.initial++; // Atomicity error will eventually be triggered here because testing class is accessing to ONE
                        // EvenGerator.
        this.initial++;
        return this.initial;
    }

    // Visibly using a lock to protect the critical section.
    public int nextWithLock() {

        lock.lock();
        try {
            this.initial++;
            this.initial++;
        }
        finally {
            lock.unlock();
        }
        return this.initial;
    }

    public void cancel() {
        this.isCanceled = true;
    }

    public boolean isCanceled() {
        return this.isCanceled;
    }
}

class EvenCheck implements Runnable {
    private final EvenGenerator even;
    private final boolean sync;

    public EvenCheck(final EvenGenerator even, final boolean sync) {
        this.even = even;
        this.sync = sync;
    }

    @Override
    public void run() {
        while (!this.even.isCanceled()) {
            final int test;
            if (this.sync == true) {
                test = this.even.next();
            } else {
                test = this.even.nextAsync();
            }
            System.out.println(test);
            if (test % 2 != 0) {
                System.out.println("This is not even!: " + test);
                this.even.cancel();
            }
        }
    }

    public static void test(final EvenGenerator even, final int count, final boolean sync) {
        final ExecutorService es = Executors.newCachedThreadPool();
        for (int i = 0; i < count; i++) {
            es.execute(new EvenCheck(even, sync));
        }
        es.shutdown();
    }

    public static void test(final EvenGenerator even, final boolean sync) {
        test(even, 10, sync);
    }
}

class EvenCheckWithLock implements Runnable {
    private final EvenGenerator even;

    public EvenCheckWithLock(final EvenGenerator even) {
        this.even = even;
    }

    @Override
    public void run() {
        while (!this.even.isCanceled()) {
            final int test = this.even.nextWithLock();
            if (test % 2 != 0) {
                System.out.println("This is not even!: " + test);
                this.even.cancel();
            }
        }
    }

    public static void test(final EvenGenerator even, final int count) {
        final ExecutorService es = Executors.newCachedThreadPool();
        for (int i = 0; i < count; i++) {
            es.execute(new EvenCheckWithLock(even));
        }
        es.shutdown();
    }

    public static void test(final EvenGenerator even) {
        test(even, 10);
    }
}